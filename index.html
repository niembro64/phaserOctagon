<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>Collision Detection Comparison: Naive vs Raycast</title>
  <style>
    body{margin:0;overflow:hidden;display:flex;justify-content:center;align-items:center;height:100vh;background:#f0f0f0;font-family:'Courier New',Courier,monospace}
    canvas{border:1px solid #333;background:#fff;box-shadow:0 0 10px rgba(0,0,0,.1)}
    .controls{position:absolute;bottom:20px;padding:10px;background:rgba(255,255,255,.9);border-radius:5px;display:flex;flex-direction:column;gap:10px}
    .slider-container{display:flex;align-items:center;gap:10px;width:380px}
    .slider-container label{width:100px;flex-shrink:0}
    .slider-container input[type="range"]{flex:1;min-width:0}
    .slider-container span{width:60px;flex-shrink:0;text-align:right}
    .shape-selector{display:flex;gap:10px;margin-bottom:5px;align-items:center}
    .shape-selector label{display:flex;align-items:center;gap:5px;cursor:pointer}
    button{padding:8px 16px;cursor:pointer;background:#4CAF50;color:#fff;border:none;border-radius:4px;font-family:'Courier New',Courier,monospace}
    button:hover{background:#45a049}
  </style>
</head>
<body>
<canvas id="canvas" width="600" height="600"></canvas>
<div class="controls">
  <div class="shape-selector">
    <strong>Collisions:</strong>
    <label><input type="radio" name="collisionMode" value="naive" checked> Naive</label>
    <label><input type="radio" name="collisionMode" value="raycast"> Raycast</label>
  </div>
  <div class="shape-selector">
    <strong>Shape:</strong>
    <label><input type="radio" name="shape" value="3" checked> Triangle</label>
    <label><input type="radio" name="shape" value="4"> Rectangle</label>
    <label><input type="radio" name="shape" value="6"> Hexagon</label>
  </div>
  <div class="slider-container">
    <label for="gravity">Gravity:</label>
    <input type="range" id="gravity" min="0" max="0.5" step="0.01" value="0.2">
    <span id="gravityValue">+0.00</span>
  </div>
  <div class="slider-container">
    <label for="rotation">Rotation:</label>
    <input type="range" id="rotation" min="-0.5" max="0.5" step="0.001" value="0.01">
    <span id="rotationValue">+0.00</span>
  </div>
  <div class="slider-container">
    <label for="elasticity">Bounce:</label>
    <input type="range" id="elasticity" min="0.1" max="0.99" step="0.01" value="0.99">
    <span id="elasticityValue">+0.00</span>
  </div>
  <button id="resetButton">Reset Simulation</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;
const CX = W/2, CY = H/2;

// Controls
const gravitySlider = document.getElementById('gravity');
const rotationSlider = document.getElementById('rotation');
const elasticitySlider = document.getElementById('elasticity');
const resetButton = document.getElementById('resetButton');
const gravityValue = document.getElementById('gravityValue');
const rotationValue = document.getElementById('rotationValue');
const elasticityValue = document.getElementById('elasticityValue');
const shapeRadios = document.querySelectorAll('input[name="shape"]');
const collisionRadios = document.querySelectorAll('input[name="collisionMode"]');

function fmt(x){ const s = parseFloat(x).toFixed(2); return s>=0?`+${s}`:s; }

// Parameters
let gravity = parseFloat(gravitySlider.value);
let omega = parseFloat(rotationSlider.value); // rad per 60Hz unit
let eRest = parseFloat(elasticitySlider.value);
let mode = 'naive';

let sides = 3;
const R_POLY = 220;
let theta = 0;

// Balls
const R_BALL = 15, N_BALL = 5;
let balls = [];
function newBall(){
  const a = Math.random()*Math.PI*2, d = Math.random()*80;
  return {
    x: CX + Math.cos(a)*d,
    y: CY + Math.sin(a)*d,
    vx: (Math.random()-0.5)*4,
    vy: (Math.random()-0.5)*4,
    radius: R_BALL,
    color: `rgb(${55+Math.floor(Math.random()*200)},${55+Math.floor(Math.random()*200)},${55+Math.floor(Math.random()*200)})`
  };
}
function resetBalls(){ balls = Array.from({length:N_BALL}, newBall); }
resetBalls();

// UI
gravityValue.textContent = fmt(gravity);
rotationValue.textContent = fmt(omega);
elasticityValue.textContent = fmt(eRest);
gravitySlider.addEventListener('input',()=>{gravity=parseFloat(gravitySlider.value); gravityValue.textContent=fmt(gravity);});
rotationSlider.addEventListener('input',()=>{omega=parseFloat(rotationSlider.value); rotationValue.textContent=fmt(omega);});
elasticitySlider.addEventListener('input',()=>{eRest=parseFloat(elasticitySlider.value); elasticityValue.textContent=fmt(eRest);});
resetButton.addEventListener('click', resetBalls);
shapeRadios.forEach(r=>r.addEventListener('change',e=>{sides=parseInt(e.target.value,10); resetBalls();}));
collisionRadios.forEach(r=>r.addEventListener('change',e=>{mode=e.target.value;}));

// Geometry
function getVerticesWorld(){
  const verts = [];
  if(sides === 4){
    // Rectangle: width > height (elongated)
    const w = R_POLY * 1.8, h = R_POLY * 0.7;
    const corners = [
      {x: -w/2, y: -h/2},
      {x:  w/2, y: -h/2},
      {x:  w/2, y:  h/2},
      {x: -w/2, y:  h/2}
    ];
    for(const c of corners){
      const rotated = rot(c.x, c.y, theta);
      verts.push({x: CX + rotated.x, y: CY + rotated.y});
    }
  } else {
    for(let i=0;i<sides;i++){
      const a = theta + i*2*Math.PI/sides;
      verts.push({x:CX + R_POLY*Math.cos(a), y:CY + R_POLY*Math.sin(a)});
    }
  }
  return verts;
}
function drawPolygon(verts){
  ctx.beginPath();
  ctx.moveTo(verts[0].x, verts[0].y);
  for(let i=1;i<verts.length;i++) ctx.lineTo(verts[i].x, verts[i].y);
  ctx.closePath();
  ctx.strokeStyle = '#333';
  ctx.lineWidth = 3;
  ctx.stroke();
}
function drawBall(b){
  ctx.beginPath();
  ctx.arc(b.x,b.y,b.radius,0,Math.PI*2);
  ctx.fillStyle=b.color; ctx.fill();
  ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.stroke();
}

// Linear algebra
function rot(x,y,a){ const c=Math.cos(a), s=Math.sin(a); return {x:c*x - s*y, y:s*x + c*y}; }
function worldToLocalPoint(x,y){ const dx=x-CX, dy=y-CY; return rot(dx,dy,-theta); }
function localToWorldPoint(x,y){ const p=rot(x,y,theta); return {x:p.x+CX, y:p.y+CY}; }
function worldToLocalVec(vx,vy){ return rot(vx,vy,-theta); }
function localToWorldVec(vx,vy){ return rot(vx,vy,theta); }
function dot(ax,ay,bx,by){ return ax*bx + ay*by; }

const EPS = 1e-7;

// Build edges in LOCAL frame (static polygon this frame)
function buildEdgesLocal(vertsWorld){
  // Map to local
  const verts = vertsWorld.map(p=>worldToLocalPoint(p.x,p.y));
  // Ensure CCW ordering (compute signed area)
  let area = 0;
  for(let i=0;i<verts.length;i++){
    const a=verts[i], b=verts[(i+1)%verts.length];
    area += a.x*b.y - b.x*a.y;
  }
  const CCW = area > 0;
  if(!CCW) verts.reverse();

  const centroid = {x:0,y:0};
  for(const v of verts){ centroid.x += v.x; centroid.y += v.y; }
  centroid.x /= verts.length; centroid.y /= verts.length;

  const edges=[];
  for(let i=0;i<verts.length;i++){
    const a=verts[i], b=verts[(i+1)%verts.length];
    const ex=b.x-a.x, ey=b.y-a.y;
    const L = Math.hypot(ex,ey);
    const ehat = {x:ex/L, y:ey/L};
    // Inward normal for CCW is left normal
    let nx = -ehat.y, ny = ehat.x;
    // Safety flip if mis-oriented (rare)
    const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    const toC = {x:centroid.x-mx, y:centroid.y-my};
    if (nx*toC.x + ny*toC.y < 0){ nx=-nx; ny=-ny; }
    edges.push({a,b,L,ehat,n:{x:nx,y:ny}});
  }
  return {edges, vertsLocal:verts};
}

// Quadratic solve sorted
function solveQuadratic(a,b,c){
  const D=b*b-4*a*c; if(D<0) return [];
  const s=Math.sqrt(D);
  const q=-(b + Math.sign(b||1)*s)/2;
  return [q/a, c/q].sort((u,v)=>u-v);
}

// Swept circle TOI in LOCAL frame (static polygon this frame)
function sweptTOI_Local(p0, v, R, edges){
  let bestT = Infinity, bestN=null;

  // Edge planes offset by R
  for(const ed of edges){
    const nx=ed.n.x, ny=ed.n.y;
    const denom = dot(nx,ny, v.x,v.y);
    if (denom >= -EPS) continue; // not moving into plane

    const dist0 = R - dot(nx,ny, p0.x - ed.a.x, p0.y - ed.a.y);
    const t = dist0 / denom;
    if (t < -EPS || t > 1 + EPS) continue;

    const qx = p0.x + v.x*t, qy = p0.y + v.y*t;
    const ex=ed.b.x - ed.a.x, ey=ed.b.y - ed.a.y, L2 = ed.L*ed.L;
    const u = ((qx - ed.a.x)*ex + (qy - ed.a.y)*ey)/L2;
    if (u >= -EPS && u <= 1 + EPS){
      if (t < bestT){ bestT=Math.max(0,t); bestN={x:nx,y:ny}; }
    }
  }

  // Vertex discs radius R
  for(const ed of edges){
    for(const c of [ed.a, ed.b]){
      const rx = p0.x - c.x, ry = p0.y - c.y;
      const A = dot(v.x,v.y, v.x,v.y);
      if (A < EPS) continue;
      const B = 2*dot(v.x,v.y, rx,ry);
      const C = dot(rx,ry, rx,ry) - R*R;
      const roots = solveQuadratic(A,B,C);
      for(const t of roots){
        if (t < -EPS || t > 1 + EPS) continue;
        const qx = p0.x + v.x*t, qy = p0.y + v.y*t;
        let nx = qx - c.x, ny = qy - c.y;
        const len = Math.hypot(nx,ny); if (len < EPS) continue;
        nx/=len; ny/=len;
        if (dot(v.x,v.y,nx,ny) >= -EPS) continue;
        if (t < bestT){ bestT=Math.max(0,t); bestN={x:nx,y:ny}; }
      }
    }
  }

  if (bestT !== Infinity) return {hit:true,t:bestT,n:bestN};
  return {hit:false};
}

// Integrate one frame in LOCAL frame using continuous raycast
function integrateRaycastLocal(ball, vertsWorld, dt){
  const {edges} = buildEdgesLocal(vertsWorld);

  // Transform ball to local
  let pL = worldToLocalPoint(ball.x, ball.y);
  let vL = worldToLocalVec(ball.vx, ball.vy);

  let remaining = dt;
  const maxHits = 3;

  for(let i=0;i<maxHits && remaining>EPS;i++){
    // Scale velocity to unit interval by displacement over remaining
    const vStep = {x:vL.x*remaining, y:vL.y*remaining};
    const toi = sweptTOI_Local(pL, vStep, ball.radius, edges);

    if (!toi.hit){
      // No hit: advance whole remaining
      pL.x += vL.x*remaining;
      pL.y += vL.y*remaining;
      remaining = 0;
      break;
    }

    // Advance to impact
    pL.x += vL.x * (remaining * toi.t);
    pL.y += vL.y * (remaining * toi.t);

    // Reflect velocity in LOCAL frame
    const vrn = vL.x*toi.n.x + vL.y*toi.n.y;
    if (vrn < 0){
      const j = (1 + eRest) * vrn;
      vL.x -= j * toi.n.x;
      vL.y -= j * toi.n.y;
    }

    // Nudge inward
    pL.x += toi.n.x * 1e-4;
    pL.y += toi.n.y * 1e-4;

    // Consume time
    remaining *= (1 - toi.t);
  }

  // Final advance for any leftover
  if (remaining > EPS){
    pL.x += vL.x * remaining;
    pL.y += vL.y * remaining;
    remaining = 0;
  }

  // Correct small drift if outside
  const {edges:edges2} = buildEdgesLocal(vertsWorld);
  let worstD = 0, worstN = null;
  for(const ed of edges2){
    const d = ( (pL.x - ed.a.x)*ed.n.x + (pL.y - ed.a.y)*ed.n.y ) - ball.radius;
    if (d < worstD){ worstD = d; worstN = ed.n; }
  }
  if (worstD < -1e-4 && worstN){
    pL.x -= worstD * worstN.x;
    pL.y -= worstD * worstN.y;
    const vn = vL.x*worstN.x + vL.y*worstN.y;
    if (vn < 0){
      const j = (1 + eRest) * vn;
      vL.x -= j * worstN.x;
      vL.y -= j * worstN.y;
    }
  }

  // Back to world
  const pW = localToWorldPoint(pL.x, pL.y);
  const vW = localToWorldVec(vL.x, vL.y);
  ball.x = pW.x; ball.y = pW.y;
  ball.vx = vW.x; ball.vy = vW.y;
}

// Naive overlap comparator
function naiveEdgeCheck(ball, verts){
  for(let i=0;i<verts.length;i++){
    const p1=verts[i], p2=verts[(i+1)%verts.length];
    const sx=p2.x-p1.x, sy=p2.y-p1.y, sl=Math.hypot(sx,sy);
    const vx=ball.x-p1.x, vy=ball.y-p1.y, proj=(vx*sx+vy*sy)/sl;
    let cx,cy;
    if (proj<=0){ cx=p1.x; cy=p1.y; }
    else if (proj>=sl){ cx=p2.x; cy=p2.y; }
    else { cx=p1.x + (proj*sx)/sl; cy=p1.y + (proj*sy)/sl; }
    const dx=ball.x-cx, dy=ball.y-cy, dist=Math.hypot(dx,dy);
    if (dist<ball.radius){
      const nx=dx/dist, ny=dy/dist, overlap=ball.radius-dist;
      ball.x += nx*overlap; ball.y += ny*overlap;
      const vn = ball.vx*nx + ball.vy*ny;
      if (vn<0){ const j=(-1 - eRest)*vn; ball.vx += j*nx; ball.vy += j*ny; }
    }
  }
}

// Ray visualization (world)
function raycastVisual(point, verts){
  let inside=false, x=point.x, y=point.y, xs=[];
  for(let i=0,j=verts.length-1;i<verts.length;j=i++){
    const xi=verts[i].x, yi=verts[i].y, xj=verts[j].x, yj=verts[j].y;
    const hit = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi) + xi);
    if (hit){ inside=!inside; const ix=(xj-xi)*(y-yi)/(yj-yi)+xi; xs.push({x:ix,y}); }
  }
  return {inside, xs};
}
function drawRays(b, verts){
  const res = raycastVisual({x:b.x,y:b.y}, verts);
  ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(W, b.y);
  ctx.strokeStyle = res.inside ? 'rgba(0,160,0,.75)' : 'rgba(200,0,0,.75)';
  ctx.lineWidth = 4; ctx.stroke();
  for(const p of res.xs){
    ctx.beginPath(); ctx.arc(p.x,p.y,5,0,Math.PI*2);
    ctx.fillStyle = res.inside ? 'rgba(0,160,0,.95)' : 'rgba(220,0,0,.95)';
    ctx.fill(); ctx.strokeStyle='#000'; ctx.lineWidth=1; ctx.stroke();
  }
  ctx.fillStyle = res.inside ? 'green' : 'red';
  ctx.font = '18px "Courier New",Courier,monospace';
  ctx.fillText(`${res.xs.length}`, b.x+22, b.y-8);
}

// Animation
let last=null;
function animate(){
  ctx.clearRect(0,0,W,H);
  const now=performance.now();
  const dt = Math.min((now-(last||now))/16.667, 2); // vs 60Hz
  last = now;

  theta += omega * dt;
  const vertsWorld = getVerticesWorld();
  drawPolygon(vertsWorld);

  for(const b of balls){
    // Forces in world (zero friction assumed)
    b.vy += gravity * dt;

    if (mode==='naive'){
      b.x += b.vx * dt; b.y += b.vy * dt;
      naiveEdgeCheck(b, vertsWorld);
    } else {
      // Local-frame continuous raycast
      integrateRaycastLocal(b, vertsWorld, dt);
    }

    // Canvas fallback
    if (b.x < b.radius){ b.x=b.radius; b.vx=Math.abs(b.vx)*eRest; }
    else if (b.x > W-b.radius){ b.x=W-b.radius; b.vx=-Math.abs(b.vx)*eRest; }
    if (b.y < b.radius){ b.y=b.radius; b.vy=Math.abs(b.vy)*eRest; }
    else if (b.y > H-b.radius){ b.y=H-b.radius; b.vy=-Math.abs(b.vy)*eRest; }
  }

  // Ball-ball
  for(let i=0;i<balls.length;i++){
    for(let j=i+1;j<balls.length;j++){
      const a=balls[i], b=balls[j];
      const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy), min=a.radius+b.radius;
      if (dist<min){
        const nx=dx/dist, ny=dy/dist, overlap=min-dist;
        a.x -= nx*overlap*0.5; a.y -= ny*overlap*0.5;
        b.x += nx*overlap*0.5; b.y += ny*overlap*0.5;
        const dvx=b.vx-a.vx, dvy=b.vy-a.vy, dvn=dvx*nx+dvy*ny;
        if (dvn<0){ const j=dvn*eRest; a.vx+=j*nx; a.vy+=j*ny; b.vx-=j*nx; b.vy-=j*ny; }
      }
    }
  }

  for(const b of balls) drawBall(b);
  if (mode==='raycast') for(const b of balls) drawRays(b, vertsWorld);

  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
