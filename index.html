<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Collision Detection Comparison: Naive vs Raycast</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
      font-family: Arial, sans-serif;
    }
    canvas {
      border: 1px solid #333;
      background-color: #fff;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
    }
    .controls {
      position: absolute;
      bottom: 20px;
      padding: 10px;
      background-color: rgba(255, 255, 255, 0.8);
      border-radius: 5px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .slider-container {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 300px;
    }
    .slider-container label { width: 120px; }
    .shape-selector {
      display: flex;
      gap: 10px;
      margin-bottom: 5px;
      align-items: center;
    }
    .shape-selector label {
      display: flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
    }
    button {
      padding: 8px 16px;
      cursor: pointer;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
    }
    button:hover { background-color: #45a049; }
  </style>
</head>
<body>
  <canvas id="canvas" width="600" height="600"></canvas>
  <div class="controls">
    <div class="shape-selector">
      <strong>Collision Mode:</strong>
      <label><input type="radio" name="collisionMode" value="naive" checked /> Naive</label>
      <label><input type="radio" name="collisionMode" value="raycast" /> Raycast</label>
    </div>
    <div class="shape-selector">
      <strong>Shape:</strong>
      <label><input type="radio" name="shape" value="3" checked /> Triangle</label>
      <label><input type="radio" name="shape" value="4" /> Square</label>
      <label><input type="radio" name="shape" value="6" /> Hexagon</label>
    </div>
    <div class="slider-container">
      <label for="gravity">Gravity:</label>
      <input type="range" id="gravity" min="0" max="0.5" step="0.01" value="0.2">
      <span id="gravityValue">+0.00</span>
    </div>
    <div class="slider-container">
      <label for="friction">Friction:</label>
      <input type="range" id="friction" min="0" max="0.1" step="0.001" value="0">
      <span id="frictionValue">+0.00</span>
    </div>
    <div class="slider-container">
      <label for="rotation">Rotation Speed:</label>
      <input type="range" id="rotation" min="-0.03" max="0.5" step="0.001" value="0.01">
      <span id="rotationValue">+0.00</span>
    </div>
    <div class="slider-container">
      <label for="elasticity">Ball Elasticity:</label>
      <input type="range" id="elasticity" min="0.1" max="0.99" step="0.01" value="0.99">
      <span id="elasticityValue">+0.00</span>
    </div>
    <button id="resetButton">Reset Simulation</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width, height = canvas.height;
    const centerX = width / 2, centerY = height / 2;

    // Controls
    const gravitySlider = document.getElementById('gravity');
    const frictionSlider = document.getElementById('friction');
    const rotationSlider = document.getElementById('rotation');
    const elasticitySlider = document.getElementById('elasticity');
    const resetButton = document.getElementById('resetButton');
    const gravityValue = document.getElementById('gravityValue');
    const frictionValue = document.getElementById('frictionValue');
    const rotationValue = document.getElementById('rotationValue');
    const elasticityValue = document.getElementById('elasticityValue');
    const shapeRadios = document.querySelectorAll('input[name="shape"]');
    const collisionModeRadios = document.querySelectorAll('input[name="collisionMode"]');

    function formatNumber(value) {
      const num = parseFloat(value).toFixed(2);
      return num >= 0 ? '+' + num : num;
    }

    // Physics parameters
    let gravity = parseFloat(gravitySlider.value);
    let friction = parseFloat(frictionSlider.value);
    let rotationSpeed = parseFloat(rotationSlider.value);
    let ballElasticity = parseFloat(elasticitySlider.value);

    // Collision mode
    let collisionMode = 'naive'; // 'naive' or 'raycast' (raycast = rays shown + robust half-space resolution)

    // Shape parameters
    let shapeSides = 3;
    const shapeRadius = 220;
    let shapeAngle = 0;

    // Balls
    const BALL_RADIUS = 15;
    const NUM_BALLS = 5;
    let balls = [];

    function resetBall() {
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * 80;
      return {
        x: centerX + Math.cos(angle) * distance,
        y: centerY + Math.sin(angle) * distance,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        radius: BALL_RADIUS,
        color: `rgb(${Math.floor(Math.random() * 200 + 55)}, ${Math.floor(Math.random() * 200 + 55)}, ${Math.floor(Math.random() * 200 + 55)})`
      };
    }

    function initializeBalls() {
      balls = [];
      for (let i = 0; i < NUM_BALLS; i++) balls.push(resetBall());
    }
    initializeBalls();

    gravityValue.textContent = formatNumber(gravity);
    frictionValue.textContent = formatNumber(friction);
    rotationValue.textContent = formatNumber(rotationSpeed);
    elasticityValue.textContent = formatNumber(ballElasticity);

    gravitySlider.addEventListener('input', () => {
      gravity = parseFloat(gravitySlider.value);
      gravityValue.textContent = formatNumber(gravity);
    });
    frictionSlider.addEventListener('input', () => {
      friction = parseFloat(frictionSlider.value);
      frictionValue.textContent = formatNumber(friction);
    });
    rotationSlider.addEventListener('input', () => {
      rotationSpeed = parseFloat(rotationSlider.value);
      rotationValue.textContent = formatNumber(rotationSpeed);
    });
    elasticitySlider.addEventListener('input', () => {
      ballElasticity = parseFloat(elasticitySlider.value);
      elasticityValue.textContent = formatNumber(ballElasticity);
    });
    resetButton.addEventListener('click', () => { initializeBalls(); });
    shapeRadios.forEach(r => r.addEventListener('change', e => {
      shapeSides = parseInt(e.target.value, 10);
      initializeBalls();
    }));
    collisionModeRadios.forEach(r => r.addEventListener('change', e => {
      collisionMode = e.target.value;
    }));

    function getShapeVertices() {
      const vertices = [];
      for (let i = 0; i < shapeSides; i++) {
        const angleOffset = shapeSides === 4 ? Math.PI / 4 : 0;
        const a = shapeAngle + angleOffset + (i * 2 * Math.PI / shapeSides);
        vertices.push({
          x: centerX + shapeRadius * Math.cos(a),
          y: centerY + shapeRadius * Math.sin(a)
        });
      }
      return vertices;
    }

    function drawShape(vertices) {
      ctx.beginPath();
      ctx.moveTo(vertices[0].x, vertices[0].y);
      for (let i = 1; i < vertices.length; i++) ctx.lineTo(vertices[i].x, vertices[i].y);
      ctx.closePath();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    function drawBall(ball) {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = ball.color;
      ctx.fill();
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    // ===== Naive edge overlap check (kept for comparison) =====
    function checkCollision(ball, p1, p2) {
      const segX = p2.x - p1.x, segY = p2.y - p1.y;
      const segLen = Math.hypot(segX, segY);

      const vx = ball.x - p1.x, vy = ball.y - p1.y;
      const proj = (vx * segX + vy * segY) / segLen;

      let cx, cy;
      if (proj <= 0) { cx = p1.x; cy = p1.y; }
      else if (proj >= segLen) { cx = p2.x; cy = p2.y; }
      else { cx = p1.x + (proj * segX) / segLen; cy = p1.y + (proj * segY) / segLen; }

      const dx = ball.x - cx, dy = ball.y - cy;
      const dist = Math.hypot(dx, dy);

      if (dist < ball.radius) {
        const overlap = ball.radius - dist;
        const ndx = dx / dist, ndy = dy / dist;

        ball.x += overlap * ndx;
        ball.y += overlap * ndy;

        const vn = ball.vx * ndx + ball.vy * ndy;
        if (vn < 0) {
          const newVn = -vn * ballElasticity;
          ball.vx += (newVn - vn) * ndx;
          ball.vy += (newVn - vn) * ndy;
        }
        return true;
      }
      return false;
    }

    // ===== Robust circle vs convex polygon resolution (half-spaces) =====
    function polygonCentroid(vertices) {
      let cx = 0, cy = 0;
      for (const v of vertices) { cx += v.x; cy += v.y; }
      const n = vertices.length;
      return { x: cx / n, y: cy / n };
    }

    function inwardNormal(p1, p2, centroid) {
      const ex = p2.x - p1.x, ey = p2.y - p1.y;
      let nx = -ey, ny = ex; // left normal
      const mx = (p1.x + p2.x) * 0.5, my = (p1.y + p2.y) * 0.5;
      const tcx = centroid.x - mx, tcy = centroid.y - my;
      if (nx * tcx + ny * tcy < 0) { nx = -nx; ny = -ny; }
      const len = Math.hypot(nx, ny);
      return { x: nx / len, y: ny / len };
    }

    function resolveCirclePolygon(ball, vertices, centroid) {
      const R = ball.radius;
      for (let i = 0; i < vertices.length; i++) {
        const p1 = vertices[i];
        const p2 = vertices[(i + 1) % vertices.length];
        const n = inwardNormal(p1, p2, centroid);

        // signed distance to inward half-space minus radius
        const dx = ball.x - p1.x, dy = ball.y - p1.y;
        const d = (dx * n.x + dy * n.y) - R;

        const vdotn = ball.vx * n.x + ball.vy * n.y;

        if (d < 0 && vdotn < 0) {
          // position correction
          ball.x -= d * n.x; // d < 0 ⇒ push inward
          ball.y -= d * n.y;

          // velocity reflection with elasticity
          const impulse = (1 + ballElasticity) * vdotn;
          ball.vx -= impulse * n.x;
          ball.vy -= impulse * n.y;

          return; // resolve one edge per frame
        }
      }
    }

    // ===== Ray casting for visualization only =====
    // Returns { isInside, intersections[] } when debug=true, else boolean
    function isPointInPolygon(point, vertices, debug = false) {
      let inside = false;
      const x = point.x, y = point.y;
      const intersections = [];

      for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
        const xi = vertices[i].x, yi = vertices[i].y;
        const xj = vertices[j].x, yj = vertices[j].y;

        const intersect = ((yi > y) !== (yj > y)) &&
                          (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

        if (intersect) {
          inside = !inside;
          if (debug) {
            const ix = (xj - xi) * (y - yi) / (yj - yi) + xi;
            intersections.push({ x: ix, y: y });
          }
        }
      }

      return debug ? { isInside: inside, intersections } : inside;
    }

    function drawRaycast(ball, vertices) {
      const res = isPointInPolygon({ x: ball.x, y: ball.y }, vertices, true);

      // Ray line
      ctx.beginPath();
      ctx.moveTo(ball.x, ball.y);
      ctx.lineTo(width, ball.y);
      ctx.strokeStyle = res.isInside ? 'rgba(0, 160, 0, 0.35)' : 'rgba(200, 0, 0, 0.35)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Intersections
      for (const p of res.intersections) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3.5, 0, Math.PI * 2);
        ctx.fillStyle = res.isInside ? 'rgba(0, 160, 0, 0.9)' : 'rgba(220, 0, 0, 0.9)';
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
      }

      // Count
      ctx.fillStyle = res.isInside ? 'green' : 'red';
      ctx.font = '10px Arial';
      ctx.fillText(`${res.intersections.length}`, ball.x + 20, ball.y - 5);
    }

    // ===== Ball-ball collisions (equal mass) =====
    function checkBallCollision(ball1, ball2) {
      const dx = ball2.x - ball1.x;
      const dy = ball2.y - ball1.y;
      const dist = Math.hypot(dx, dy);
      const minDist = ball1.radius + ball2.radius;

      if (dist < minDist) {
        const overlap = minDist - dist;
        const nx = dx / dist, ny = dy / dist;

        ball1.x -= nx * overlap * 0.5;
        ball1.y -= ny * overlap * 0.5;
        ball2.x += nx * overlap * 0.5;
        ball2.y += ny * overlap * 0.5;

        const dvx = ball2.vx - ball1.vx;
        const dvy = ball2.vy - ball1.vy;
        const dvn = dvx * nx + dvy * ny;

        if (dvn < 0) {
          const j = dvn * ballElasticity;
          ball1.vx += j * nx;
          ball1.vy += j * ny;
          ball2.vx -= j * nx;
          ball2.vy -= j * ny;
        }
      }
    }

    // Animation
    let lastTime = null;

    function animate() {
      ctx.clearRect(0, 0, width, height);

      const now = performance.now();
      const deltaTime = now - (lastTime || now);
      lastTime = now;
      const timeStep = Math.min(deltaTime / 16.667, 2);

      shapeAngle += rotationSpeed * timeStep;
      const vertices = getShapeVertices();
      const centroid = polygonCentroid(vertices);

      drawShape(vertices);

      // Integrate motion and resolve
      for (const ball of balls) {
        ball.vy += gravity * timeStep;

        const decay = Math.pow(1 - friction, timeStep);
        ball.vx *= decay;
        ball.vy *= decay;

        ball.x += ball.vx * timeStep;
        ball.y += ball.vy * timeStep;

        if (collisionMode === 'naive') {
          for (let i = 0; i < vertices.length; i++) {
            const p1 = vertices[i];
            const p2 = vertices[(i + 1) % vertices.length];
            checkCollision(ball, p1, p2);
          }
        } else if (collisionMode === 'raycast') {
          // Robust half-space resolution; rays are visualization only
          resolveCirclePolygon(ball, vertices, centroid);
        }

        // Canvas bounds fallback
        if (ball.x < ball.radius) {
          ball.x = ball.radius;
          ball.vx = Math.abs(ball.vx) * ballElasticity;
        } else if (ball.x > width - ball.radius) {
          ball.x = width - ball.radius;
          ball.vx = -Math.abs(ball.vx) * ballElasticity;
        }
        if (ball.y < ball.radius) {
          ball.y = ball.radius;
          ball.vy = Math.abs(ball.vy) * ballElasticity;
        } else if (ball.y > height - ball.radius) {
          ball.y = height - ball.radius;
          ball.vy = -Math.abs(ball.vy) * ballElasticity;
        }
      }

      // Ball-ball collisions
      for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
          checkBallCollision(balls[i], balls[j]);
        }
      }

      // Draw balls
      for (const ball of balls) drawBall(ball);

      // Draw rays if raycast mode
      if (collisionMode === 'raycast') {
        for (const ball of balls) drawRaycast(ball, vertices);
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
